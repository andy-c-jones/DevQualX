@namespace DevQualX.Web.Components.Library.Atoms
@using Microsoft.AspNetCore.Components.Forms

<div class="form-field @Class">
    @if (!string.IsNullOrEmpty(Label))
    {
        <label for="@Id" class="form-field__label">
            @Label
            @if (Required)
            {
                <span class="form-field__required" aria-label="required">*</span>
            }
        </label>
    }
    
    <div class="form-field__input-wrapper">
        @if (LeadingIcon != null)
        {
            <div class="form-field__icon form-field__icon--leading">
                @LeadingIcon
            </div>
        }
        
        <input 
            type="@Type.ToString().ToLowerInvariant()"
            id="@Id"
            name="@Name"
            class="form-field__input @(HasError ? "form-field__input--error" : "") @(LeadingIcon != null ? "form-field__input--with-leading-icon" : "") @(TrailingIcon != null ? "form-field__input--with-trailing-icon" : "")"
            value="@Value"
            placeholder="@Placeholder"
            disabled="@Disabled"
            readonly="@Readonly"
            required="@Required"
            minlength="@MinLength"
            maxlength="@MaxLength"
            min="@Min"
            max="@Max"
            pattern="@Pattern"
            aria-describedby="@(string.IsNullOrEmpty(HelperText) && string.IsNullOrEmpty(ErrorMessage) ? null : $"{Id}-description")"
            aria-invalid="@HasError"
            data-validation-message="@ValidationMessage"
            @oninput="HandleInput"
            @onchange="HandleChange"
            @attributes="AdditionalAttributes" />
        
        @if (TrailingIcon != null)
        {
            <div class="form-field__icon form-field__icon--trailing">
                @TrailingIcon
            </div>
        }
    </div>
    
    @if (!string.IsNullOrEmpty(HelperText) || !string.IsNullOrEmpty(ErrorMessage))
    {
        <div id="@($"{Id}-description")" class="form-field__description">
            @if (HasError && !string.IsNullOrEmpty(ErrorMessage))
            {
                <span class="form-field__error">@ErrorMessage</span>
            }
            else if (!string.IsNullOrEmpty(HelperText))
            {
                <span class="form-field__helper">@HelperText</span>
            }
        </div>
    }
</div>

@code {
    private static int _nextId = 0;
    private string _id = string.Empty;
    
    /// <summary>
    /// The current value of the input.
    /// </summary>
    [Parameter]
    public string? Value { get; set; }
    
    /// <summary>
    /// Callback invoked when the value changes.
    /// </summary>
    [Parameter]
    public EventCallback<string?> ValueChanged { get; set; }
    
    /// <summary>
    /// Input type (Text, Email, Password, Number, etc.).
    /// </summary>
    [Parameter]
    public InputType Type { get; set; } = InputType.Text;
    
    /// <summary>
    /// Input label text.
    /// </summary>
    [Parameter]
    public string? Label { get; set; }
    
    /// <summary>
    /// Input name attribute (for forms).
    /// </summary>
    [Parameter]
    public string? Name { get; set; }
    
    /// <summary>
    /// Input ID attribute. Auto-generated if not provided.
    /// </summary>
    [Parameter]
    public string? Id { get; set; }
    
    /// <summary>
    /// Placeholder text.
    /// </summary>
    [Parameter]
    public string? Placeholder { get; set; }
    
    /// <summary>
    /// Helper text displayed below the input.
    /// </summary>
    [Parameter]
    public string? HelperText { get; set; }
    
    /// <summary>
    /// Error message displayed when HasError is true.
    /// </summary>
    [Parameter]
    public string? ErrorMessage { get; set; }
    
    /// <summary>
    /// Whether the input has a validation error.
    /// </summary>
    [Parameter]
    public bool HasError { get; set; }
    
    /// <summary>
    /// Whether the input is disabled.
    /// </summary>
    [Parameter]
    public bool Disabled { get; set; }
    
    /// <summary>
    /// Whether the input is readonly.
    /// </summary>
    [Parameter]
    public bool Readonly { get; set; }
    
    /// <summary>
    /// Whether the input is required.
    /// </summary>
    [Parameter]
    public bool Required { get; set; }
    
    /// <summary>
    /// Minimum length for text inputs.
    /// </summary>
    [Parameter]
    public int? MinLength { get; set; }
    
    /// <summary>
    /// Maximum length for text inputs.
    /// </summary>
    [Parameter]
    public int? MaxLength { get; set; }
    
    /// <summary>
    /// Minimum value for number inputs.
    /// </summary>
    [Parameter]
    public string? Min { get; set; }
    
    /// <summary>
    /// Maximum value for number inputs.
    /// </summary>
    [Parameter]
    public string? Max { get; set; }
    
    /// <summary>
    /// Regex pattern for validation.
    /// </summary>
    [Parameter]
    public string? Pattern { get; set; }
    
    /// <summary>
    /// Custom validation message for client-side validation.
    /// </summary>
    [Parameter]
    public string? ValidationMessage { get; set; }
    
    /// <summary>
    /// Leading icon content.
    /// </summary>
    [Parameter]
    public RenderFragment? LeadingIcon { get; set; }
    
    /// <summary>
    /// Trailing icon content.
    /// </summary>
    [Parameter]
    public RenderFragment? TrailingIcon { get; set; }
    
    /// <summary>
    /// Additional CSS classes.
    /// </summary>
    [Parameter]
    public string? Class { get; set; }
    
    /// <summary>
    /// Additional HTML attributes.
    /// </summary>
    [Parameter(CaptureUnmatchedValues = true)]
    public Dictionary<string, object>? AdditionalAttributes { get; set; }
    
    protected override void OnInitialized()
    {
        if (string.IsNullOrEmpty(Id))
        {
            _id = $"input-{Interlocked.Increment(ref _nextId)}";
        }
        else
        {
            _id = Id;
        }
    }
    
    private async Task HandleInput(ChangeEventArgs e)
    {
        Value = e.Value?.ToString();
        await ValueChanged.InvokeAsync(Value);
    }
    
    private async Task HandleChange(ChangeEventArgs e)
    {
        Value = e.Value?.ToString();
        await ValueChanged.InvokeAsync(Value);
    }
}
